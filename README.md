20.7.14.

객체지향의 세계에서는 모든 것이 변한다.
여기서 변한다는 것은 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다.
소프트웨어 개발에서 끝이란 개념은 없다.
그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 '미래의 변화를 어떻게 대비할 것인가'이다.

객체지향 기술은 변화에 효과적으로 대체할 수 있다.
객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고,
이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다.

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까?
분리와 확장을 고려한 설계가 필요하다.

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
하지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다면? ...
변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은
한 가지 관심이 한 군데에 집중되게 하는 것이다.
즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

UserDao의 메소드를 살펴보면 다음의 관심사항을 발견할 수 있다.
1. DB와 연결을 위한 connection 가져오기
-어떤 DB를 쓸 것인가
-어떤 드라이버를 사용할 것인가
-어떤 로그인 정보를 사용할 것인가
-connection 생성 방법은 어떻게 할 것인가

2. DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행

3. 리소스(Statement, Connection) 반납

###1 단계. Connection 만들기 추출

가장 먼저 할 일은 connection을 가져오는 중복된 코드를 분리하는 것이다.
getConnection()이라는 이름의 독립적인 메소드를 만들었다.

이젠 클라이언트 쪽에서 연결을 알아서 구현하도록 수정해보자.
UserDao를 추상클래스로 만들고 getConnection()을 추상메소드로 만들었다.
다음으로 가상의 클라이언트 Dao를 만든 뒤,
클라이언트 Dao에서 UserDao를 상속받아 getConnection만 구현하도록 하였다.
이렇게 수퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를
추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을
디자인 패턴에서 템플릿 메소드 패턴이라고 한다.
템플릿 메소드 패턴은 스프링에서 애용되는 디자인 패턴이다.
서브클래스에서 구체적인 객체 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴이라고 부르기도 한다.

상속은 한계가 있다.
1. 이미 UserDao가 다른 목적을 위해 상속을 사용하고 있는 경우 상속을 이용할 수 없다(자바는 클래스 다중상속 불가능)
2. 상속을 통한 상하위 클래스 관계는 생각보다 밀접하다
   서브클래스는 수퍼클래스의 기능을 직접 사용할 수 있고, 따라서 수퍼클래스 내부의 변경이 있을 때
   모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.
3. 확장된 기능인 DB connection 생성 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다.


###2 단계. DAO 확장(interface 이용)

이번에는 관심사가 다르고 변화의 성격이 다른 코드를 더 화끈하게 분리해보도록 한다.
아예 상속관계도 아닌 완전히 독립적인 클래스로 만드는 것이다.
이제 더이상 클라이언트가 DB connection 기능 확장해서 사용할 수 없게 된다
UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되버리기 때문에
UserDao 코드의 수정 없이 DB connection 생성 기능을 변경할 방법이 없다.
이렇게 클래스를 분리한 경우에도 자유로운 확장이 가능하려면 두 가지가 해결되어야 한다.
1. SimpleConnectionMaker의 메소드 이름과
클라이언트에서 만든 DB connection 제공 클래스의 메소드 이름이 불일치 할 수 있다.
2. DB connection을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다.
UserDao에 SimpleConnectionMaker라는 클래스 타입의 인스턴스 변수까지 정의해놓고 있기 때문.
이런 문제의 근본 원인은 UserDao가 바뀔 수 있는 정보,
즉 DB connection을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다.
어떤 클래스가 쓰일지, 그 클래스에서 connection을 가져오는 메소드의 이름이 뭔지까지 일일이 알고 있어야 한다.
따라서 UserDao는 DB connection을 가져오는 코드에 종속되어 버린다.
클라이언트가 DB connection을 가져오는 방법을 자유롭게 확장하기가 힘들어졌다.

20.7.16.

클래스를 분리하면서도 이런 문제를 해결할 수 없을까?
두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들면 된다.
추상화란 어떤 것들의 공통적 성격을 뽑아내어 이를 따로 분리해내는 작업인데,
자바가 추상화를 위해 제공하는 가장 유용한 도구가 바로 인터페이스다.
인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다.
결국 객체를 만들려면 구체적인 클래스 하나를 선택해야겠지만
인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들 때
사용할 클래스가 무엇인지 몰라도 된다.
인터페이스를 통해 접근하게 되면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.
ConnectionMaker라는 이름의 인터페이스를 만들어
클라이언트 쪽에서 connection 생성 코드를 알아서 만들도록 수정하자.
(의존관계가 UserDao와 인터페이스 사이에 형성되기 때문에
인터페이스 구현 클래스와의 관계가 느슨해지면서 변화에 영향을 덜 받는 상태가 되었다.)
수정을 하고 보니 UserDao의 인스턴스 변수 ConnectionMaker 객체를 생성할 때
클라이언트의 클래스 이름이 나온다는 문제가 생겼다.
ex) connectionMaker = new KakaoConnectionMaker();
이렇게 되면 클라이언트에게 UserDao 소스코드를 제공해야만 한다.
수정할 때 UserDao의 소스코드를 직접 수정해주어야 하기 때문이다.

UserDao 안에 분리되지 않은, 또 다른 관심사항이 있다.
바로 어떤 ConnectionMaker 클래스를 사용할 것인가 하는 문제이다.
매우 짧고 간단하지만 그 자체로 충분히 독립적인 관심사이다.
이 관심사를 담은 코드를 UserDao에서 분리하지 않으면
UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.
UserDao 객체와 ConnectionMaker 구현 클래스 객체의 관계를 결정하는 기능은
클라이언트 오브젝트에 두도록 하자. UserDao의 모든 코드가 ConnectionMaker 인터페이스 외에
다른 어떤 클래스와도 관계를 갖지 않도록 말이다.
외부(클라이언트 객체)에서 만든 객체를 전달받으려면
메소드 파라미터나 생성자 파라미터를 이용하면 된다.

주의)
클래스 사이에 만들어진 관계와 객체 사이에 만들어진 관계는 다르다.
UserDao에서 ConnectionMaker 구현 클래스로 KakaoConnectionMaker 클래스를 사용하면,
이는 클래스 사이에 관계가 형성된 것이다.
하지만 다형성이라는 특징을 이용해 인터페이스로 연결하여
런타임에 해당 인터페이스를 구현한 클래스 객체를 받게한다면,
이는 특정 클래스와 관계를 맺은 것이 아니라
런타임시에 객체 사이에 관계가 형성된 것이다.

클라이언트는 자기가 UserDao를 사용해야 할 입장이기 때문에
UserDao의 세부 전략이라고도 볼 수 있는 ConnectionMaker의 구현 클래스를 선택하고,
선택한 클래스의 객체를 생성해서 UserDao와 연결해줄 수 있다.
기존의 UserDao에서는 생성자에게 이 책임이 있었다.
자신이 사용할 객체를 직접 만들어서, 자신과 관계를 만들어버리는 것이 기존 UserDao 생성자가 한 일이다.
하지만 이는 UserDao의 관심도 아니고 책임도 아니다. 다른 관심사가 함께 있으니 확장성을 떨어뜨렸던 것이다.
자, 이제 이 다른 관심을 분리해서 클라이언트에게 떠넘겨보자.
클라이언트에서 ConnectionMaker 구현 클래스를 정하고 객체를 생성하여 UserDao의 생성자에 전달하게 수정하였다.
이제 UserDao의 생성자는 ConnectionMaker 인터페이스를 구현했다면
어떤 클래스로 만든 오브젝트라도 상관도 없고 관심도 없다.

20.7.17.

얼렁뚱땅 넘긴 게 하나 있다. 클라이언트인 UserDaoTest이다.
UserDaoTest는 UserDao 기능이 잘 동작하는지 테스트하려고 만든 것이다.
근데 지금은 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 책임까지 떠맡았으니 뭔가 문제가 있다.
성격이 다른 책임이나 관심사는 지금껏 분리해왔기 때문이다. 이것도 분리하자.
분리시킬 기능을 담당할 클래스 DaoFactory를 만들자.
이로써 애플리케이션 컴포넌트 역할을 하는 객체(클라이언트, UserDao, ConnectionMaker)와
애플리케이션 구조를 결정하는 객체(DaoFactory)가 분리되었다.

20.7.19.

DaoFactory를 좀 더 살펴보자.
DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능을 넣고 싶다.
AccountDao, MessageDao 등..
근데 userDao() 메소드를 복사해서 accountDao(), messageDao() 메소드로 만들면
ConnectionMaker 구현 클래스의 객체를 생성하는 코드가 메소드마다 반복된다.
(어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 기능이 중복돼서 나타난다.)
이럴 경우 DAO가 더 많아지면 ConnectionMaker의 구현 클래스를 바꿀 때마다
모든 메소드를 일일이 수정해야 한다.
ConnectionMaker 구현 클래스의 객체를 생성하는 코드를
connectionMaker()라는 이름의 메소드로 뽑아내자.

이제 제어의 역전에 대해 알아보자.
제어의 역전은 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.
객체가 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하는 것으로
자신이 사용할 객체를 스스로 선택하거나 생성하지 않고,
어떻게 만들어지고 어디서 사용되지 알 수 없다.
UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다.
자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해
DaoFactory를 도입했던 과정이 바로 IoC를 적용하는 작업이었다고 볼 수 있다.

제어의 역전에서는 프레임워크 또는 컨테이너와 같이
애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.
DaoFactory는 객체 수준의 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크라고 불릴 수 있다.

스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 객체를 빈 팩토리라 부른다.
보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트를 사용한다.

DaoFactory는 자체가 설정정보까지 담고 있는 IoC 엔진이었으나
이제 자바 코드로 만든 애플리케이션 컨텍스트가 사용할 설정정보로 만든 뒤,
애플리케이션 컨텍스트를 만들어보자.

20.7.20.

XML을 이용하여 애플리케이션 컨텍스트를 만들어보자.

자바에서는 DB 커넥션을 가져오는 객체의 기능을 추상화해서
비슷한 용도로 사용할 수 있게 만들어진 DataSource라는 인터페이스가 이미 존재한다.
따라서 실전에서 ConnectionMaker와 같은 인터페이스를 만들어서 사용할 일은 없을 것이다.
DataSource를 구현하는 일도 거의 없다. 이미 DB 연결과 pooling 기능을 갖춘
많은 DataSource 구현 클래스가 존재하기 때문이다.
DataSource 인터페이스와 다양한 DataSource 구현 클래스를 사용할 수 있도록 UserDao를 리팩토링해보자.

20.7.24.

UserDaoTest에 아쉬운 점이 있다.
하나는 수동으로 확인해야 한다는 점이다.
add()에서 User 정보를 DB에 등록하고, 이를 다시 get()으로 가져왔을 때
값이 일치하는지를 테스트 코드가 확인해주지 않는다.
단지 콘솔에 값을 출력할 뿐이고, 사람이 눈으로 확인해야 한다.
또 하나는 실행하기가 번거롭다는 점이다.
DAO가 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면,
전체 기능을 테스트해보기 위해 main() 메소드를 수백 번 실행해야 한다.
main() 메소드를 이용하는 방법보다 좀 더 편리하고 체계적으로 테스트를 실행하고
그 결과를 확인하는 방법이 필요하다.

먼저 첫 번째 문제점을 개선해보자.
테스트 코드에서 결과를 직접 확인하고,
기대한 결과와 달라서 실패했을 경우에는
"테스트 실패"라는 메시지를 출력하도록 만들어보자.
그리고 모든 확인 작업을 통과하면 그때 "테스트 성공"을 출력하자.

20.7.26.

좀 더 편리하게 테스트를 수행하고 편리하게 결과를 확인하려면
단순한 main() 메소드로는 한계가 있다
일정한 패턴을 가진 테스트를 만들 수 있고,
많은 테스트를 간단히 실행시킬 수 있으며,
테스트 결과를 종합해서 볼 수 있고,
테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘
테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.
JUnit 프레임워크를 사용하자.

deleteAll()과 getCount() 메소드를 추가해보자.
두 메소드에 대한 테스트는 기존의 addAndGet() 테스트에 추가한다.

20.7.27.

getCount()에 대한 더 꼼꼼한 테스트를 만들어보자.
테스트를 안 만드는 것도 위험하지만,
성의 없이 테스트를 만드는 바람에
문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다.
테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 게 좋으니까
getCount()를 위한 새로운 테스트 메소드를 작성하도록 한다.

addAndGet() 테스트를 보완해보자.

UserDao의 get()에 존재하지 않는 user id가 전달된 경우를 처리해보자.
스프링의 EmptyResultDataAccessException 예외를 이용한다.

20.7.28.

지금까지 세 개의 테스트 메소드를 만들었다. 이쯤 해서 테스트 코드를 리팩토링해보자.

UserDaoTest 코드를 잘 살펴보면 기계적으로 반복되는 부분이 있다.
스프링의 애플리케이션 컨텍스트를 만드는 부분과
컨텍스트에서 UserDao를 가져오는 부분이다.
메소드 추출 리팩토링 방법 말고 JUnit이 제공하는 기능을 활용해보자.

JUnit 프레임워크는 테스트 메소드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다.
그중에서 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣게 해주고,
이를 매번 테스트 메소드를 실행하기 전에 먼저 실행시켜주는 기능이다. @Before

테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 한다.
일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에
@Before 메소드를 이용해 생성해두면 편리하다.
User 객체도 픽스처라고 볼 수 있으므로 @Before 메소드에 추가하자.

@Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에
애플리케이션 컨텍스트도 여러번 만들어진다는 점이 찜찜하다.
빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다.
애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 객체를 초기화한다.
1. 어떤 빈은 객체가 생성될 때 자체적인 초기화 작업을 진행해서
제법 많은 시간을 필요로 한다.
2. 어떤 빈은 독자적을 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다.
이런 경우 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스 등을
깔끔하게 정리해주지 않으면 다음 테스트에서 애플리케이션 컨텍스트가 만들어지면서 문제가 생길 수도 있다.
때문에 애플리케이션 컨텍스트는 테스트 전체가 공유하는 객체로 만들기도 한다.
테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 @BeforeClass 스태틱 메소드를 이용하여
애플리케이션 컨텍스트를 스태틱 변수에 저장할 수 있다.
하지만 이보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하자. @RunWith

20.7.29.

스프링 테스트 컨텍스트 프레임워크의 기능은
하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것이 전부가 아니다.
여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면,
스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.

20.8.3.

##3장 템플릿

UserDao 코드에 아직 문제가 남아 있다. 예외상황에 대한 처리이다.
deleteAll() 메소드에서 Connection과 PreparedStatement라는 두 개의 공유 리소스를 사용하는데,
close()를 호출하여 리소스를 반환하기 전에 예외가 발생한다면
리소스를 반환하지 않은 채로 메소드를 빠져나갈지도 모른다.
(보통 pool 방식으로 운영되어 미리 제한된 수의 리소스를 만들어두고
필요할 때 할당하고, 다 쓰면 반환하여 다시 풀에 넣기 때문에
제대로 반환되지 않으면 풀에 있는 리소스가 고갈될 수 있다.)
try with를 이용하여 예외를 처리하자.

템플릿 메소드 패턴을 이용해서 변하는 부분과 변하지 않는 부분을 분리해보자.
템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용한다.
몇 가지 문제가 있다.
1. DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.
즉, UserDao의 JDBC 메소드가 4개이면 4개의 서브클래스가 필요하다.
2. 확장구조가 클래스를 설계하는 시점에 고정된다.
변하지 않는 부분과 변하는 부분이 이미 클래스 레벨에서 컴파일 시점에 그 관계가 결정되어 있다.
(클라이언트(UserDaoTest)에서 deleteAll() 메소드를 쓰려면
UserDaoDeleteAll과 같이 구체적인 클래스와 관계를 직접 맺어야 한다는 의미인가?
아님 UserDao와 UserDaoDeleteAll가 관계되어 있다는 의미인가.)
관계에 대한 유연성이 떨어진다.

전략 패턴을 적용해보자.
객체를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만든다.
개방 폐쇄 원칙을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어나다.
컨텍스트(변하지 않는 부분)는 일정한 구조를 가지고 동작하다가
특정 확장 기능은 인터페이스(전략에 해당)를 통해 외부의 독립된 전략 클래스에 위임한다.
deleteAll()로 따지면 컨텍스트는 다음과 같다.
- DB 커넥션 가져오기
- PreparedStatement 만들어줄 외부 기능 호출하기
- 전달받은 PreparedStatement 실행하기
- 예외 발생시 이를 메소드 밖으로 던지기
- 어떤 경우든 PreparedStatement와 Connection 닫기
두 번째 작업에서 사용하는 PreparedStatement를 만들어주는 외부 기능이 바로
전략 패턴에서 말하는 전략이라고 볼 수 있다.

전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서 전략을 바꿔 쓸 수 있어야 하는데
컨텍스트 안에서 이미 구체적인 전략 클래스 DeleteAllStatement를 사용하도록 고정되어 있다.
뭔가 이상하다. 컨텍스트가 StatementStrategy 인터페이스뿐 아니라 특정 구현 클래스인
DeleteAllStatement도 직접 알고 있다는건 전략 패턴에도, OCP에도 잘 들어맞지 않는다.

전략 패턴에 따르면 컨텍스트가 어떤 전략을 사용하게 할 것인가는
클라이언트가 결정하는 게 일반적이다. 클라이언트가 구체적인 전략의 하나를 선택하고
객체로 만들어서 컨텍스트에 전달하는 것이다.
그렇다. 이건 DI다. DI란 결국 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조이다.
컨텍스트에 해당하는 부분을 별도의 메소드로 독립시켜보자.
클라이언트는 전략 클래스 객체를 컨텍스트 메소드로 전달해야 한다.

이번엔 add() 메소드에도 적용해보자.

20.8.6.

좀 더 개선할 부분을 찾아보자.
1. DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다.
2. DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적 정보가 있는 경우
이를 위해 객체를 전달받는 생성자와 이를 저장해둘 인스턴스 변수가 필요하다.

StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고
UserDao 클래스 안에 내부 클래스로 정의하자.
DeleteAllStatement나 AddStatement 모두 UserDao에서만 사용되고,
UserDao의 메소드 로직에 강하게 결합되어 있다.

익명 내부 클래스로 바꿔보자.

UserDao의 메소드가 클라이언트이고,
익명 내부 클래스가 개별적인 전략이고,
jdbcContextWithStatementStrategy() 메소드가 컨텍스트이다.
jdbcContextWithStatementStrategy()는 일반적인 작업 흐름을 담고 있어서
다른 DAO에서도 사용가능하므로 UserDao 클래스 밖으로 독립시켜서 모든 DAO가 사용할 수 있게 하자.

20.8.7.

UserDao와 StatementStrategy, JdbcContext를 이용해 만든 코드는
일종의 전략 패턴이 적용된 것이라고 볼 수 있다.
복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고
그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조다.
전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다.
이런 방식을 스프링에서는 템플릿/콜백 패턴이라고 부른다.
전략 패턴의 컨텍스트를 템플릿이라 부르고,
익명 내부 클래스로 만들어지는 객체를 콜백이라고 부른다.

템플릿/콜백 방식에서 한 가지 아쉬운 점이 있다.
DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에
상대적으로 코드를 작성하고 읽기가 불편하다는 점이다.
복잡한 익명 내부 클래스의 사용을 최소화할 수 있는 방법을 찾아보자.
deleteAll() 메소드에서 변하지 않는 부분(익명 내부 클래스를 정의하고 생성하는 부분)을
executeSql()라는 이름의 메소드로 추출하자.

한 단계 더 나아가자. executeSql()은 재사용 가능한 콜백을 담고 있는 메소드이므로
DAO가 공유할 수 있는 템플릿 클래스(JdbcContext) 안으로 옮겨도 된다.

정리
결합을 느슨하게 하기 위해 인터페이스 사용
-> 매번 인터페이스를 구현하는 클래스가 생성되므로 내부 클래스 이용
-> 익명 내부 클래스로 개선
-> 익명 내부 클래스를 정의하고 생성하는 로직이 반복되므로
반복되는 부분(템플릿)과 변하는 부분(콜백)을 분리

20.8.18. 템플릿/콜백 예제를 만들어보자.

파일의 모든 숫자를 더하는 기능을 만들었는데
모든 숫자의 곱을 계산하는 기능을 추가해야 한다는 요구가 발생했다고 가정해보자.
뿐만 아니라 앞으로 숫자 데이터를 여러 방식으로 처리하는 기능이 추가될 것이라는 소식이 들려왔다면?
자, 템플릿/콜백 패턴을 적용해보자.
템플릿/콜백을 적용할 때는 템플릿과 콜백의 경계를 정하고
템플릿이 콜백에게, 콜백이 템플릿에게 각각 전달하는 내용이 무엇인지 파악하는 게 가장 중요하다.

가장 쉽게 생각해볼 수 있는 구조는 템플릿이 파일을 열고 각 라인을 읽어올 수 있는
BufferedReader를 만들어서 콜백에게 전달해주고,
콜백이 각 라인을 읽어서 알아서 처리한 후에 최종 결과만 템플릿에게 돌려주는 것이다.

템플릿/콜백 패턴을 적용해서 try/catch/finally 블록이 없도록 깔끔하게 정리하였다.
calcSum()과 calcMultiply()에 나오는 콜백을 비교해보면 공통적인 패턴을 발견할 수 있다.
라인을 한 줄 한 줄 읽는 것까지 똑같고, 그 한 줄을 어떻게 처리하느냐만 다르다.
따라서 LineCallback 이라는 인터페이스를 새로 만들고,
라인을 읽는 것까지 템플릿에 넣고, 라인을 가지고 처리하는 부분만 콜백으로 두자.
(그래서 이름이 LineCallback이다.)
템플릿/콜백을 재설계해보자.

앞에서 만들었던 코드보다 깔끔하고 보기 좋다.
여타 로우레벨의 파일 처리 코드가 템플릿으로 분리되고
순수한 계산 로직만 남아 있기 때문에 코드의 관심이 무엇인지 명확하게 보인다.
Calculator 클래스와 메소드는 데이터를 가져와 계산한다는
핵심 기능에 충실한 코드만 갖고 있게 됐다.

20.9.5. 이제부턴 마크다운으로 작성해보자.

###제네릭스를 이용한 콜백 인터페이스
지금까지 사용한 LineCallBack과 lineReadTemplate()은 템플릿과 콜백이 만들어내는 결과가 Integer 타입으로 고정되어 있다.
파일을 라인 단위로 처리해서 만드는 결과의 타입을 다양하게 가져가고 싶다면, 제네릭스를 이용하면 된다.

20.9.6.

스프링이 제공하는 템플릿/콜백 기술을 살펴보자.
스프링이 제공하는 JDBC 코드용 기본 템플릿은 JdbcTemplate이다.
JdbcContext는 버리고 JdbcTemplate으로 바꿔보자.

20.9.11.

3장 끝.

##4장 예외

4장에서는 JdbcTemplate을 대표로 하는 스프링의 데이터 액세스 기능에 담겨 있는 예외처리와 관련된 접근 방법을 알아본다.
이를 통해 예외를 처리하는 best practice도 살펴본다.

20.10.8.

##5장 서비스 추상화

UserDao에 간단한 비즈니스 로직을 추가해보자.

- 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다.
- 사용자가 처음 가입하면 BASIC 레벨, 이후 활동에 따라 한 단계씩 업그레이드 가능하다.
- 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER가 된다.
- SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD가 된다.
- 사용자 레벨 변경 작업은 일정한 주기를 가지고 일괄적으로 한다.
변경 작업 전에는 조건을 충족하더라도 레벨 변경이 일어나지 않는다.

필드를 추가하자.

1. Level 이늄 추가
<br> 숫자 타입을 직접 사용하는 것보다는 enum을 사용하는 게
안전하고 편리하다.

2. User 필드 추가
<br> User에 Level 타입 필드와 로그인 횟수, 추천받은 횟수를
 나타내는 필드를 추가한다.
 
 20.10.9.
 
 사용자 수정 기능을 추가했다. 사용자 관리 비즈니스
 로직에 따르면 사용자 정보는 여러 번 수정될 수 있으니 말이다.
 
 만들어야 할 코드의 기능을 생각해볼 겸 테스트를 먼저 작성한다.
 
 사용자 레벨을 업그레이드 해주는 upgradeLevels 메소드를 추가했다.
 이는 비즈니스 로직이므로 UserService라는 클래스를 만들어
 그 안에 넣었다.
 
 코드 개선을 해보자.
 - 코드에 중복된 부분은 없는가
 - 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가
 - 코드가 자신이 있어야 할 자리에 있는가
 - 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고,
 그 변화에 쉽게 대응할 수 있게 작성되어 있는가
 
 #### upgradeLevels() 개선

for 루프 속 if/elseif/else 블록들이 읽기 불편하다.
성격이 다른 여러 조직이 한데 섞여있는 상태이다.
if 조건 블록은 레벨 개수만큼 반복되는데 새로운 레벨이 추가될 경우
Level 이늄도 수정해야 하고, upgradeLevels()의
레벨 업그레이드 로직을 담은 코드에 if 조건식과
블록을 추가해줘야 한다. 즉, 지금의 코드는
변화에 취약하고 다루기 힘든 상태이다. 리팩토링을 해보자.

UserService는 User에게 레벨 업그레이드 작업을 해달라고
요청하고, User는 Level에게 다음 레벨이 무엇인지
알려달라고 요청하는 방식으로 리팩토링 되었다.
더 이해하기 쉽고 변화에 대응하기 편하다.
"BRONZE 레벨을 BASIZ과 SILVER 사이에 추가하고
그 다음 레벨로 업그레이드 하는 조건은 로그인 횟수 80번이다.
그리고 가장 최근의 레벨 변경 날짜를 저장해두고,
레벨 변경 시 콘솔에 로그를 남기도록 하라"는 수정
요청이 들어왔을 때, 각 요청사항은 어디를 손보면
되는지 쉽게 알 수 있다. 물론 변경 후에도
코드는 여전히 깔끔하고 이해하기 쉬울 것이다.

유저 레벨 업그레이드 정책을 유연하게 변경할 수 있도록
리팩토링해보자. 사용자 관리 로직을 담은 중요한
UserService 코드를 매번 수정하는건 번거롭고 위험하므로
업그레이드 정책을 UserService에서 분리해내고
업그레이드 정책을 담은 객체는 DI를 통해
UserService에서 사용하도록 해보자.

20.10.11.

#### Transaction

중간에 예외가 발생해서 작업을 완료할 수 없다면
아예 작업이 시작되지 않은 것처럼 초기 상태로 돌려놔야 한다.

DB는 그 자체로 완벽한 트랜잭션을 지원한다.
하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을
보장해준다고 믿을 수 있다.

사용자 레벨 업그레이드 기능의 경우 여러 개의 SQL의 합이므로
트랜잭션 처리가 필요하다. 트랜잭션 경계를 설정해보자.

트랜잭션은 하나의 Connection 안에서 이루어진다.
따라서 여러 SQL을 하나의 트랜잭션 안에 두려면
하나의 Connection 안에서 여러 SQL을 실행해야 한다.
지금의 Dao 코드는 메소드마다 Connection을 생성하기 때문에
Dao 메소드의 Connection 인자를 받게하여
하나의 Connection이 유지되도록 수정해보자. 이렇게 하면 문제가 많다.

- 리소스의 깔금한 처리를 가능하게 했던 JdbcTemplate을 더 이상 활용할 수 없다.
- UserService에 Connection 파라미터가 추가되어야 한다.
- UserDao의 메소드에도 Connection 파라미터가 추가되므로 더 이상 데이터 액세스 기술에 독립적일 수 없다.
- 테스트 코드도 수정해야 한다.

지금까지 만든 깔끔한 코드를 유지한 채로 트랜잭션 기능을 가져가기 위해
스프링이 제공하는 트랜잭션 동기화 방식을 사용해본다.

#### Transaction synchronization

Connection 객체를 특별한 저장소에 보관해두고,
이후 호출되는 DAO의 메소드에서는 저장된 Connection을
가져다가 사용하게 하는 것이다.
정확히는 DAO가 사용하는 Jdbctemplate이
트랜잭션 동기화 방식을 이용하는 것이다.
트랜잭션이 모두 종료되면, 그때는 동기화를 마치면 된다.

20.10.12.

원래 UserService는 UserDao 인터페이스에만 의존하는 구조였다.
그런데 UserService가 트랜잭션의 경계 설정을 해야 할 필요가 생기면서
특정 데이터 액세스 기술에 종속되는 구조가 되고 말았다.
HIbernate, JPA, JDO, JTA ... 다른 기술을 사용하면
UserService의 코드도 수정해줘야 하는 상황이다.
하지만 트랜잭션 경계설정을 담당하는 코드는 일정한 패턴을 가지므로
추상화를 이용하여 UserService가 DAO 기술로부터
독립되도록 해보자.

#### 스프링의 트랜잭션 서비스 추상화

스프링에서 제공하는 PlatformTransactionManager는
트랜잭션 서비스에 대한 추상화를 제공한다.
따라서 UserService에서 PlatformTransactionManager를
DI 받아 사용하게 만든다면 DAO가 바뀌더라도
UserService의 코드를 수정할 필요가 없다.

20.10.13.

#### SRP

단일 책임 원칙이란 객체지향 설계의 원칙 중 하나로
하나의 모듈이 한 가지 책임을 가져야 함을 의미한다.

PlatfromTransactionManager를 사용하기 전에
UserService는 사용자 레벨 관리와
트랜잭션 관리라른 두 가지 책임을 가지고 있었다.
UserService의 코드가 수정되는 이유가 두 가지라는 뜻이다.
사용자 관리 업무가 바뀌지 않았으나
서버환경이 바뀌어서 트랜잭션 기술을 변경해야 할 경우
UserService의 코드를 수정해야 했다.
하지만 트랜잭션 서비스 추상화 방식을 도입하고
DI를 통해 외부에서 제어하도록 하고 나서는
UserService가 사용자 관리라는 하나의 책임만을 갖게 되었다.

"DI를 잘 활용해서 스프링을 열심히 사용하다 보면,
어느 날 자신이 만든 코드에 객체지향 원칙과 디자인
패턴의 장점이 잘 녹아 있다는 사실을 발견하게 될 것이다.
그것이 스프링을 사용함으로써 얻을 수 있는
가장 큰 장점이다."

#### 5.4 메일 서비스 추상화

레벨 업그레이드되는 사용자에게 안내 메일을 발송해보자.
1. 사용자의 이메일 정보를 관리해야 한다.
2. 업그레이드 작업을 담은 UserService의 upgradeLevel 메소드에
메일 발송 기능을 추가한다.

User에 email field를 추가했다.

UserService에 JavaMail API를 사용하는 sendUpgradeEmail 메소드를 추가했다.
upgradeLevel 메소드에서 sendUpgradeEmail 메소드를 사용할 것이다.

메일 서비스 기능을 테스트를 작성하려고 할 때 몇 가지 문제가 있다.
- SMTP 메일 서버가 준비되어 있어야 테스트를 할 수 있다.
- 메일 발송이란 매우 부하가 큰 작업이다.

SMTP라는 표준 메일 발송 프로토콜로
메일 서버에 요청이 전달되기만 하면 메일이 발송될거라 믿고,
실제 메일 서버가 아닌 테스트용으로 따로 준비한
메일 서버를 사용해 테스트할 수 있지 않을까?
같은 원리로 JavaMail도 표준 기술로 이미 검증된
안정적인 모듈이므로 JavaMail을 직접 구동(부하가 매우 큼)시키지 말고
JavaMail `API를 통해 요청이 들어간다는 보장만 받는 식으로
테스트할 수 있지 않을까?

20.10.14.

문제가 있다. JavaMail의 핵심 API에는 인터페이스로 만들어져서 구현을 바꿀 수 있는 게 없다.
스프링이 제공하는 JavaMail 추상화 기능(MailSender 클래스)을 사용해보자.

일반적으로 서비스 추상화라고 하면 기능은 유사하나
사용 방법이 다른 로우레벨의 다양한 기술에 대해
추상 인터페이스와 일관성 있는 접근 방법을 제공해주는 것을 말한다.
반면에 JavaMail의 경우처럼 테스트를 어렵게 만드는
건전하지 않은 방식으로 설계된 API를 사용할 때도 유용하게 쓰일 수 있다.
서비스 추상화란 원활한 테스트만을 위해서도 충분히 가치가 있다.
JavaMail처럼 확장이 불가능하게 설계해놓은 API를 사용해야 하는
경우라면 추상화 계층의 도입을 적극 고려해볼 필요가 있다.
특별히 외부의 리소스와 연동하는 대부분 작업은 추상화의
대상이 될 수 있다.

스프링이 제공하는 MailSender를 구현한 추상화 클래스는
JavaMailServiceImpl 하나뿐이다. 그럼에도 이 추상화된 메일
전송 기능을 사용함으로써 얻을 수 있는 장점은 크다.

어떤 경우에도 UserService와 같은 애플리케이션 계층의 코드는
아래 계층에서는 어떤 일이 일어나는지 상관없이 메일 발송을
요청한다는 기본 기능에 충실하게 작성하면 된다. 메일 서버가 바뀌고
메일 발송 방식이 바뀌는 등의 변화가 있어도 메일을 발송한다는
비즈니스 로직이 바뀌지 않는 한 UserService는 수정할 필요가 없다.

20.10.16.

테스트 환경을 만들어주기 위해, 테스트 대상이 되는 오브젝트의
기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수
있도록 사용하는 이런 오브젝트를 통틀어서 테스트 대역이라고 부른다.
대표적인 테스트 대역은 테스트 스텁이다. 테스트 스텁은
테스트 대상 오브젝트의 의존객체로서 존재하면서
테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것을 말한다.

테스트 대상 오브젝트의 메소드가 돌려주는 결과뿐 아니라
테스트 오브젝트가 간접적으로 의존 오브젝트에 넘기는 값과
그 행위 자체에 대해서도 검증하고 싶다면
목 오브젝트를 사용해야 한다. 목 오브젝트는 스텁처럼
테스트 오브젝트가 정상적으로 실행되도록 도와주면서,
테스트 오브젝트와 자신의 사이에서 일어나는 커뮤니케이션
내용을 저장해뒀다가 테스트 결과를 검증하는데 활용할 수
있게 해준다.

UserServiceTest에 이 개념을 적용해보자.
의존 오브젝트 대체 역할만 했던 DummyMailSender 대신
MockMailSender를 만들어 커뮤니케이션 내용을 저장하게 하고,
이를 테스트 결과 검증에 활용해보자.

목 오브젝트를 이용한 테스트는 작성하기 간단하면서도
기능은 상당히 막강하다. 보통 테스트 방법으로 검증하기가
매우 까다로운 테스트 대상 오브젝트의 내부에서 일어나는
일이나 다른 오브젝트 사이에서 주고받는 정보까지
검증하는 일이 손쉽기 때문이다.

테스트가 수행될 수 있도록 의존 오브젝트에 간접적으로
입력 값을 제공해주는 스텁 오브젝트와 간접적인
출력 값까지 확인이 가능한 목 오브젝트,
이 두 가지는 테스트 대역의 가장 대표적인 방법이며
효과적인 테스트 코드를 작성하는 데 빠질 수 없는
중요한 도구다.

20.10.17.

##6장 AOP

트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세려된고 깔끔한 방식으로 바꿔보자.

스프링이 제공하는 깔끔한 트랜잭션 인터페이스를 썼음에도 비즈니스 로직이 주인이어야
할 메소드 안에 이름도 길고 무시무시하게 생긴 트랜잭션 코드가 더 많은 자리를
차지하고 있는 모습이 못마땅하다.

upgradeLevels 메소드를 다시 살펴보자.
자세히 살펴보면 비즈니스 로직 코드를 사이에 두고
트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치하고 있으며
트랜잭션 경계설정 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다.
완벽하게 독립적인 코드다. 다만 이 비즈니스 로직을 담당하는 코드가
트랜잭션의 시작과 종료 작업 사이에서 수행돼야 한다는 사항만 지켜지면 된다.
일단 비즈니스 로직 담당 코드를 메소드로 추출해서 독립시켜보자.

깔끔해졌지만 여전히 트랜잭션 경계설정 코드가 UserService 안에 자리 잡고 있다.
트랜잭션 코드를 클래스 밖으로 뽑아서 UserService에서 아예 안보이게 만들어보자.

UserService는 클래스이다. 따라서 UserService에서 트랜잭션 코드를 빼내면
UserService를 직접 사용하는 클라이언트는 트랜잭션이 빠진 UserService를
쓰게 된다. 직접 사용을 간접 사용으로 바꿔보자.

UserService: interface
UserServiceImpl: 비즈니스 로직
UserServiceTx: 트랜잭션 경계설정(비즈니스 로직은 Impl에 위임)

이렇게 함으로써 얻을 수 있는 또 하나의 장점은
비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다는 것이다.
그건 다음에 살펴본다.

20.10.18.

가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다. 작은 단위의 테스트가 좋은 이유는 실패했을 때 그 원인을 찾기 쉽기 때문이다.
또한 테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고 만들기도 쉬워진다.
하지만 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

UserService만 보더라도 매우 간단한 기능을 갖고 있지만 UserService의 구현 클래스들이 동작하려면 세 가지 타입의 의존 오브젝트가 필요하다.
하지만 UserServiceTest는 UserService의 비즈니스 로직 구현 코드만 테스트하면 된다.

테스트의 대상이 환경이나 외부 서버, 다른 클래스의 코드에 종속되지 않고, 영향을 받지 않도록 고립시킬 필요가 있다.
테스트를 의존 대상으로부터 분리해서 고립시키는 방법은 테스트를 위한 대역을 사용하는 것이다.

고립된 단위 테스트 방법을 UserService의 upgradeLevels() 테스트에 적용해보자.

고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없을 뿐만 아니라,
테스트 수행 능력도 크게 향상된다. 테스트가 빨리 돌아가면 부담 없이 자주 테스트를 돌려볼 수 있다.

#### 목 프레임워크

단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다.
단위 테스트가 많은 장점을 가지고 있고 가장 우선시해야 할 테스트 방법인 건 사실이지만 작성이 번거롭다.
특히 목 오브젝트를 만드는 일이 가장 큰 짐이다. 테스트에서는 사용하지 않는 인터페이스도 모두 일일이 구현해줘야 한다.
검증 기능이 있는 목 오브젝트로 만들려면, 메소드의 호출 내용을 저장했다가 이를 다시 불러오는 것도
매번 귀찮은 일이 아닐 수 없다. 특히 테스트 메소드별로 다른 검증 기능이 필요하다면, 같은 의존 인터페이스를 구현한
여러 개의 목 클래스를 선언해줘야 한다. 다행히도 이런 목 오브젝트를 편리하게 작성하도록 도와주는 목 오브젝트 지원 프레임워크가 있다.

20.10.23.

### 6.3 다이내믹 프록시와 팩토리 빈

단순히 확장성을 고려해서 한 가지 기능을 분리한다면 전략 패턴을 사용하면 된다.
하지만 전략 패턴을 사용하면 위임을 통해 기능을 사용하는 코드가 남는다.
트랜잭션이라는 기능(부가기능)와 사용자 관리 비즈니스 로직(핵심기능)처럼 성격이 다른 경우
아예 적용 사실 자체를 밖으로(별도의 클래스로) 분리할 수 있다. (위임을 통해 기능을 사용하는 코드조차 분리할 수 있다.)

##### 프록시

부가기능을 담은 클래스는 핵심기능을 사용하는 구조이며, 부가기능은 마치 자신이 핵심 기능을 가진
클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야 한다. (인터페이스 이용)
이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을
대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다. 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는
실제 오브젝트를 타깃 또는 실체(real subject)라고 부른다.
프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.
프록시는 사용 목적에 따라 두 가지로 구분할 수 있다. 첫째는 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서다.
두 번째는 타깃에 부가적인 기능을 부여해주기 위해서다. 둘 모두 프록시를 쓰지만 디자인 패턴에서는 목적에 따라 다른 패턴으로 구분한다.

##### 데코레이터 패턴

데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.
예시 `InputStream is = new BufferedInputStream(new FileInputStream("a.txt"));`
데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

##### 프록시 패턴

디자인 패턴에서 말하는 프록시 패턴은 일반적으로 사용하는 프록시와 다르다.
전자는 프록시(후자)를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.
프로깃 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
예를 들면, 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우 꼭 필요한 시점까지 오브젝트 생성을 미루는 것이 좋은데,
타깃 오브젝트에 대한 레퍼런스가 미리 필요할 수 있다. 이럴 때 프록시 패턴을 적용할 수 있다.
클라이언트에게 타깃에 대한 레퍼런스를 넘길 때 실제 타깃 오브젝트를 만드는 대신 프록시를 넘기는 것이다.
그리고 프록시의 메소드를 통해 타깃을 만드려고 할 때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.

##### 다이내믹 프록시

프록시도 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하지 않고도 편리하게 만들어서 사용할 수 있는 방법이 있다.
기본적인 아이디어는 목 프레임워크와 비슷하다. 일일이 프록시 클래스를 정의하지 않고도 몇 가지 API를 이용해 프록시처럼
동작하는 오브젝트를 다이내믹하게 생성하는 것이다. 프록시가 인터페이스의 모든 메소드를 구현하도록 일일이 코드를 짜야한다는 단점과
부가기능을 공통적으로 적용하는 경우 중복된 코드가 생긴다는 단점을 해결한다.

##### 리플렉션

다이내믹 프록시는 리플렉션 API를 이용하여 만들 수 있다.
프록시 팩토리에 특정 인터페이스의 다이내믹 프록시를 만들어달라고 요청하면,
인터페이스의 모든 메소드를 구현한 오브젝트를 생성해주고,
프록시 팩토리에 InvocationHandler 인터페이스를 구현한 오브젝트를 제공해주면,
다이내믹 프록시가 받는 모든 요청을 InvocationHandler의 invoke 메소드로 보내준다.
인터페이스의 메소드가 아무리 많더라도 invoke 메소드 하나로 처리할 수 있다.

20.10.25.

UserServiceTx를 다이내믹 프록시 방식으로 변경해보자.

이제 TransactionHandler와 다이내믹 프록시를 스프링의 DI를 통해 사용할 수 있도록 만들어보자.
그러려면 DI의 대상이 되는 다이내믹 프록시 오브젝트를 빈으로 등록해야 하는데 일반적인 스프링의 빈으로는 등록할 수 없다.
스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다.
문제는 다이내믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다는 점이다.
다이내믹 프록시 오브젝트의 클래스가 어떤 것인지도 알 수 없다. 클래스 자체도 내부적으로 다이내믹하게 새로 정의해서 사용하기 때문이다.
따라서 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링의 빈에 정의할 방법이 없다.
다이내믹 프록시는 Proxy 클래스의 newProxyInstance라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.
스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러 가지 방법을 제공한다.
대표적으로 팩토리 빈을 이용한 빈 생성 방법을 들 수 있다. 이 방법을 통하면 기본 생성자 대신 스태틱 팩토리 메소드가 제공되는 경우도 빈을 등록할 수 있다.

20.10.26.

다이내믹 프록시에 팩토리 빈을 이용한 DI까지 더해주면 번거로운 다이나믹 프록시 생성 코드조차 제거할 수 있다.
DI 설정만으로 다양한 타깃 오브젝트에 적용도 가능하다. 하지만 한 번에 여러 개의 클래스에 공통적인
부가기능을 제공하는 일은 불가능하다. 거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을 막을 수 없다.
하나의 타깃에 여러 부가기능을 적용하려고 할 때도 문제다. XML 설정파일이 복잡해지고, 비슷한 설정이 나타나게 된다.
또한 InvocationHandler 구현체가 프록시 팩토리 빈 개수만큼 만들어진다. 스프링의 해결책을 보자.

ProxyFactoryBean: 프록시를 생성해서 빈 오브젝트로 등록해주는 팩토리 빈
<br>순수하게 프록시를 생성하는 작업만 담당한다. 제공해줄 부가기능은 별도의 빈에 두어야 한다.
부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다. 이는 InvocationHandler와 비슷하지만
메소드 정보에 더해 타깃 오브젝트가 담긴 MethodInvocation 오브젝트를 ProxyFactoryBean으로부터 제공받는다.
따라서 MethodInterceptor는 타겟 오브젝트를 직접 알고 있을 필요가 없고,
타겟이 다른 여러 프록시에서 함게 사용할 수 있고 싱글톤 빈으로 등록이 가능하다.

20.10.27.

이제 ProxyFactoryBean을 적용해보자.

프록시 팩토리 빈 방식의 접근 방법의 문제 중 하나가 아직 남았다.
부가 기능의 적용이 필요한 타겟 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해야한다는 문제이다.
실제 빈 오브젝트가 되는 것은 ProxyFactoryBean이 아니라 ProxyFactoryBean를 통해 생성되는 프록시 그 자체이므로
프록시가 자동을 빈으로 생성되게 할 수 있으면 좋을 것 같다. 마치 다이내믹 프록시가 인터페이스만 제공하면
모든 메소드에 대한 구현 클래스를 자동으로 만들듯, 일정한 타겟 빈의 목록을 제공하면 자동으로 각 타겟 빈에 대한
프록시를 만들어주는 방법이 있다면 ProxyFactoryBean 타입 빈 설정을 매번 추가할 필요가 없을 것이다.

DefaultAdvisorAutoProxyCreator: 어드바이저를 이용한 자동 프록시 생성기(BeanPostProcessor 구현체)

#### 확장 포인트컷

포인트 컷은 어떤 메소드에 부가기능을 적용할지 선정해줄 수 있을 뿐만 아니라 어떤 클래스에 프록시를 적용할지도 결정할 수 있다.

20.10.28.

DefaultAdvisorAutoProxyCreator를 적용해보자.

포인트컷 표현식을 적용하고 aop 스키마 전용 태그를 사용해보자.

#### 트랜잭션 경계설정의 일원화

서비스 계층을 트랜잭션이 시작되고 종료되는 경계로 정했다면, 테스트와 같은 특별한 이유가 아니고는
다른 계층이나 모듈에서 DAO에 직접 접근하는 것은 차단해야 한다. 트랜잭션은 보통 서비스 계층의 메소드 조합을 통해
만들어지기 때문에 DAO가 제공하는 주요 기능은 서비스 계층에 위임 메소드를 만들어줄 필요가 있다.

트랜잭션 경계설정을 일원화하고 트랜잭션 속성을 가진 트랜잭션 어드바이스를 등록해보자.

#### 애노테이션 트랜잭션 속성과 포인트컷

#### 트랜잭션 지원 테스트

20.10.31.

## 7장 스프링 핵심 기술의 응용

7장에서는 SQL을 DAO에서 분리하는 작업에 도전한다. SQL 제공 기능을 분리해서 다양한 SQL 정보 소스를 사용할 수 있고,
운영 중에 동적으로 갱신도 가능한 유연하고 확장성이 뛰어난 SQL 서비스를 만들어보자.

SqlService라는 인터페이스를 만든 뒤 UserDao에서 DI 받도록 수정하였다.
이제 UserDao를 포함한 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해
전혀 신경 쓰지 않아도 된다. 구체적인 방법과 기술에 상관없이 SqlService 인터페이스 타입의 빈을 DI 받아서
필요한 SQL을 가져다 쓰기만 하면 된다.

검색용 키와 SQL 문장 두 가지를 담을 수 있는 간단한 XML 문서를 설계해보고, 이 XML 파일에서
SQL을 읽어뒀다가 DAO에게 제공해주는 SQL 서비스 구현 클래스를 만들어보자.

#### JAXB
Java Architecture for XML Binding
-> 테스트 실패

20.11.3.

토비의 스프링 3.1 vol1 1회독