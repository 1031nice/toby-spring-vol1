20.7.14.

객체지향의 세계에서는 모든 것이 변한다.
여기서 변한다는 것은 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다.
소프트웨어 개발에서 끝이란 개념은 없다.
그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 '미래의 변화를 어떻게 대비할 것인가'이다.

객체지향 기술은 변화에 효과적으로 대체할 수 있다.
객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고,
이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다.

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까?
분리와 확장을 고려한 설계가 필요하다.

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
하지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다면? ...
변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은
한 가지 관심이 한 군데에 집중되게 하는 것이다.
즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

UserDao의 메소드를 살펴보면 다음의 관심사항을 발견할 수 있다.
1. DB와 연결을 위한 connection 가져오기
-어떤 DB를 쓸 것인가
-어떤 드라이버를 사용할 것인가
-어떤 로그인 정보를 사용할 것인가
-connection 생성 방법은 어떻게 할 것인가

2. DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행

3. 리소스(Statement, Connection) 반납

###1 단계. Connection 만들기 추출

가장 먼저 할 일은 connection을 가져오는 중복된 코드를 분리하는 것이다.
getConnection()이라는 이름의 독립적인 메소드를 만들었다.

이젠 클라이언트 쪽에서 연결을 알아서 구현하도록 수정해보자.
UserDao를 추상클래스로 만들고 getConnection()을 추상메소드로 만들었다.
다음으로 가상의 클라이언트 Dao를 만든 뒤,
클라이언트 Dao에서 UserDao를 상속받아 getConnection만 구현하도록 하였다.
이렇게 수퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를
추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을
디자인 패턴에서 템플릿 메소드 패턴이라고 한다.
템플릿 메소드 패턴은 스프링에서 애용되는 디자인 패턴이다.
서브클래스에서 구체적인 객체 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴이라고 부르기도 한다.

상속은 한계가 있다.
1. 이미 UserDao가 다른 목적을 위해 상속을 사용하고 있는 경우 상속을 이용할 수 없다(자바는 클래스 다중상속 불가능)
2. 상속을 통한 상하위 클래스 관계는 생각보다 밀접하다
   서브클래스는 수퍼클래스의 기능을 직접 사용할 수 있고, 따라서 수퍼클래스 내부의 변경이 있을 때
   모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.
3. 확장된 기능인 DB connection 생성 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다.


###2 단계. DAO 확장(interface 이용)

이번에는 관심사가 다르고 변화의 성격이 다른 코드를 더 화끈하게 분리해보도록 한다.
아예 상속관계도 아닌 완전히 독립적인 클래스로 만드는 것이다.
이제 더이상 클라이언트가 DB connection 기능 확장해서 사용할 수 없게 된다
UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되버리기 때문에
UserDao 코드의 수정 없이 DB connection 생성 기능을 변경할 방법이 없다.
이렇게 클래스를 분리한 경우에도 자유로운 확장이 가능하려면 두 가지가 해결되어야 한다.
1. SimpleConnectionMaker의 메소드 이름과
클라이언트에서 만든 DB connection 제공 클래스의 메소드 이름이 불일치 할 수 있다.
2. DB connection을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다.
UserDao에 SimpleConnectionMaker라는 클래스 타입의 인스턴스 변수까지 정의해놓고 있기 때문.
이런 문제의 근본 원인은 UserDao가 바뀔 수 있는 정보,
즉 DB connection을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다.
어떤 클래스가 쓰일지, 그 클래스에서 connection을 가져오는 메소드의 이름이 뭔지까지 일일이 알고 있어야 한다.
따라서 UserDao는 DB connection을 가져오는 코드에 종속되어 버린다.
클라이언트가 DB connection을 가져오는 방법을 자유롭게 확장하기가 힘들어졌다.

20.7.16.

클래스를 분리하면서도 이런 문제를 해결할 수 없을까?
두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들면 된다.
추상화란 어떤 것들의 공통적 성격을 뽑아내어 이를 따로 분리해내는 작업인데,
자바가 추상화를 위해 제공하는 가장 유용한 도구가 바로 인터페이스다.
인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다.
결국 객체를 만들려면 구체적인 클래스 하나를 선택해야겠지만
인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들 때
사용할 클래스가 무엇인지 몰라도 된다.
인터페이스를 통해 접근하게 되면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.
ConnectionMaker라는 이름의 인터페이스를 만들어
클라이언트 쪽에서 connection 생성 코드를 알아서 만들도록 수정하자.
(의존관계가 UserDao와 인터페이스 사이에 형성되기 때문에
인터페이스 구현 클래스와의 관계가 느슨해지면서 변화에 영향을 덜 받는 상태가 되었다.)
수정을 하고 보니 UserDao의 인스턴스 변수 ConnectionMaker 객체를 생성할 때
클라이언트의 클래스 이름이 나온다는 문제가 생겼다.
ex) connectionMaker = new KakaoConnectionMaker();
이렇게 되면 클라이언트에게 UserDao 소스코드를 제공해야만 한다.
수정할 때 UserDao의 소스코드를 직접 수정해주어야 하기 때문이다.

UserDao 안에 분리되지 않은, 또 다른 관심사항이 있다.
바로 어떤 ConnectionMaker 클래스를 사용할 것인가 하는 문제이다.
매우 짧고 간단하지만 그 자체로 충분히 독립적인 관심사이다.
이 관심사를 담은 코드를 UserDao에서 분리하지 않으면
UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.
UserDao 객체와 ConnectionMaker 구현 클래스 객체의 관계를 결정하는 기능은
클라이언트 오브젝트에 두도록 하자. UserDao의 모든 코드가 ConnectionMaker 인터페이스 외에
다른 어떤 클래스와도 관계를 갖지 않도록 말이다.
외부(클라이언트 객체)에서 만든 객체를 전달받으려면
메소드 파라미터나 생성자 파라미터를 이용하면 된다.

주의)
클래스 사이에 만들어진 관계와 객체 사이에 만들어진 관계는 다르다.
UserDao에서 ConnectionMaker 구현 클래스로 KakaoConnectionMaker 클래스를 사용하면,
이는 클래스 사이에 관계가 형성된 것이다.
하지만 다형성이라는 특징을 이용해 인터페이스로 연결하여
런타임에 해당 인터페이스를 구현한 클래스 객체를 받게한다면,
이는 특정 클래스와 관계를 맺은 것이 아니라
런타임시에 객체 사이에 관계가 형성된 것이다.

클라이언트는 자기가 UserDao를 사용해야 할 입장이기 때문에
UserDao의 세부 전략이라고도 볼 수 있는 ConnectionMaker의 구현 클래스를 선택하고,
선택한 클래스의 객체를 생성해서 UserDao와 연결해줄 수 있다.
기존의 UserDao에서는 생성자에게 이 책임이 있었다.
자신이 사용할 객체를 직접 만들어서, 자신과 관계를 만들어버리는 것이 기존 UserDao 생성자가 한 일이다.
하지만 이는 UserDao의 관심도 아니고 책임도 아니다. 다른 관심사가 함께 있으니 확장성을 떨어뜨렸던 것이다.
자, 이제 이 다른 관심을 분리해서 클라이언트에게 떠넘겨보자.
클라이언트에서 ConnectionMaker 구현 클래스를 정하고 객체를 생성하여 UserDao의 생성자에 전달하게 수정하였다.
이제 UserDao의 생성자는 ConnectionMaker 인터페이스를 구현했다면
어떤 클래스로 만든 오브젝트라도 상관도 없고 관심도 없다.

20.7.17.

얼렁뚱땅 넘긴 게 하나 있다. 클라이언트인 UserDaoTest이다.
UserDaoTest는 UserDao 기능이 잘 동작하는지 테스트하려고 만든 것이다.
근데 지금은 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 책임까지 떠맡았으니 뭔가 문제가 있다.
성격이 다른 책임이나 관심사는 지금껏 분리해왔기 때문이다. 이것도 분리하자.
분리시킬 기능을 담당할 클래스 DaoFactory를 만들자.
이로써 애플리케이션 컴포넌트 역할을 하는 객체(클라이언트, UserDao, ConnectionMaker)와
애플리케이션 구조를 결정하는 객체(DaoFactory)가 분리되었다.

20.7.19.

DaoFactory를 좀 더 살펴보자.
DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능을 넣고 싶다.
AccountDao, MessageDao 등..
근데 userDao() 메소드를 복사해서 accountDao(), messageDao() 메소드로 만들면
ConnectionMaker 구현 클래스의 객체를 생성하는 코드가 메소드마다 반복된다.
(어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 기능이 중복돼서 나타난다.)
이럴 경우 DAO가 더 많아지면 ConnectionMaker의 구현 클래스를 바꿀 때마다
모든 메소드를 일일이 수정해야 한다.
ConnectionMaker 구현 클래스의 객체를 생성하는 코드를
connectionMaker()라는 이름의 메소드로 뽑아내자.

이제 제어의 역전에 대해 알아보자.
제어의 역전은 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.
객체가 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하는 것으로
자신이 사용할 객체를 스스로 선택하거나 생성하지 않고,
어떻게 만들어지고 어디서 사용되지 알 수 없다.
UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다.
자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해
DaoFactory를 도입했던 과정이 바로 IoC를 적용하는 작업이었다고 볼 수 있다.

제어의 역전에서는 프레임워크 또는 컨테이너와 같이
애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.
DaoFactory는 객체 수준의 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크라고 불릴 수 있다.

스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 객체를 빈 팩토리라 부른다.
보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트를 사용한다.

DaoFactory는 자체가 설정정보까지 담고 있는 IoC 엔진이었으나
이제 자바 코드로 만든 애플리케이션 컨텍스트가 사용할 설정정보로 만든 뒤,
애플리케이션 컨텍스트를 만들어보자.

20.7.20.

XML을 이용하여 애플리케이션 컨텍스트를 만들어보자.

자바에서는 DB 커넥션을 가져오는 객체의 기능을 추상화해서
비슷한 용도로 사용할 수 있게 만들어진 DataSource라는 인터페이스가 이미 존재한다.
따라서 실전에서 ConnectionMaker와 같은 인터페이스를 만들어서 사용할 일은 없을 것이다.
DataSource를 구현하는 일도 거의 없다. 이미 DB 연결과 pooling 기능을 갖춘
많은 DataSource 구현 클래스가 존재하기 때문이다.
DataSource 인터페이스와 다양한 DataSource 구현 클래스를 사용할 수 있도록 UserDao를 리팩토링해보자.

20.7.24.

UserDaoTest에 아쉬운 점이 있다.
하나는 수동으로 확인해야 한다는 점이다.
add()에서 User 정보를 DB에 등록하고, 이를 다시 get()으로 가져왔을 때
값이 일치하는지를 테스트 코드가 확인해주지 않는다.
단지 콘솔에 값을 출력할 뿐이고, 사람이 눈으로 확인해야 한다.
또 하나는 실행하기가 번거롭다는 점이다.
DAO가 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면,
전체 기능을 테스트해보기 위해 main() 메소드를 수백 번 실행해야 한다.
main() 메소드를 이용하는 방법보다 좀 더 편리하고 체계적으로 테스트를 실행하고
그 결과를 확인하는 방법이 필요하다.

먼저 첫 번째 문제점을 개선해보자.
테스트 코드에서 결과를 직접 확인하고,
기대한 결과와 달라서 실패했을 경우에는
"테스트 실패"라는 메시지를 출력하도록 만들어보자.
그리고 모든 확인 작업을 통과하면 그때 "테스트 성공"을 출력하자.

20.7.26.

좀 더 편리하게 테스트를 수행하고 편리하게 결과를 확인하려면
단순한 main() 메소드로는 한계가 있다
일정한 패턴을 가진 테스트를 만들 수 있고,
많은 테스트를 간단히 실행시킬 수 있으며,
테스트 결과를 종합해서 볼 수 있고,
테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘
테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.
JUnit 프레임워크를 사용하자.

deleteAll()과 getCount() 메소드를 추가해보자.
두 메소드에 대한 테스트는 기존의 addAndGet() 테스트에 추가한다.

20.7.27.

getCount()에 대한 더 꼼꼼한 테스트를 만들어보자.
테스트를 안 만드는 것도 위험하지만,
성의 없이 테스트를 만드는 바람에
문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다.
테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 게 좋으니까
getCount()를 위한 새로운 테스트 메소드를 작성하도록 한다.

addAndGet() 테스트를 보완해보자.

UserDao의 get()에 존재하지 않는 user id가 전달된 경우를 처리해보자.
스프링의 EmptyResultDataAccessException 예외를 이용한다.

20.7.28.

지금까지 세 개의 테스트 메소드를 만들었다. 이쯤 해서 테스트 코드를 리팩토링해보자.

UserDaoTest 코드를 잘 살펴보면 기계적으로 반복되는 부분이 있다.
스프링의 애플리케이션 컨텍스트를 만드는 부분과
컨텍스트에서 UserDao를 가져오는 부분이다.
메소드 추출 리팩토링 방법 말고 JUnit이 제공하는 기능을 활용해보자.

JUnit 프레임워크는 테스트 메소드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다.
그중에서 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣게 해주고,
이를 매번 테스트 메소드를 실행하기 전에 먼저 실행시켜주는 기능이다. @Before

테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 한다.
일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에
@Before 메소드를 이용해 생성해두면 편리하다.
User 객체도 픽스처라고 볼 수 있으므로 @Before 메소드에 추가하자.

@Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에
애플리케이션 컨텍스트도 여러번 만들어진다는 점이 찜찜하다.
빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다.
애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 객체를 초기화한다.
1. 어떤 빈은 객체가 생성될 때 자체적인 초기화 작업을 진행해서
제법 많은 시간을 필요로 한다.
2. 어떤 빈은 독자적을 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다.
이런 경우 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스 등을
깔끔하게 정리해주지 않으면 다음 테스트에서 애플리케이션 컨텍스트가 만들어지면서 문제가 생길 수도 있다.
때문에 애플리케이션 컨텍스트는 테스트 전체가 공유하는 객체로 만들기도 한다.
테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 @BeforeClass 스태틱 메소드를 이용하여
애플리케이션 컨텍스트를 스태틱 변수에 저장할 수 있다.
하지만 이보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하자. @RunWith

20.7.29.

스프링 테스트 컨텍스트 프레임워크의 기능은
하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것이 전부가 아니다.
여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면,
스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.

20.8.3.

##3장 템플릿

UserDao 코드에 아직 문제가 남아 있다. 예외상황에 대한 처리이다.
deleteAll() 메소드에서 Connection과 PreparedStatement라는 두 개의 공유 리소스를 사용하는데,
close()를 호출하여 리소스를 반환하기 전에 예외가 발생한다면
리소스를 반환하지 않은 채로 메소드를 빠져나갈지도 모른다.
(보통 pool 방식으로 운영되어 미리 제한된 수의 리소스를 만들어두고
필요할 때 할당하고, 다 쓰면 반환하여 다시 풀에 넣기 때문에
제대로 반환되지 않으면 풀에 있는 리소스가 고갈될 수 있다.)
try with를 이용하여 예외를 처리하자.

템플릿 메소드 패턴을 이용해서 변하는 부분과 변하지 않는 부분을 분리해보자.
템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용한다.
몇 가지 문제가 있다.
1. DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.
즉, UserDao의 JDBC 메소드가 4개이면 4개의 서브클래스가 필요하다.
2. 확장구조가 클래스를 설계하는 시점에 고정된다.
변하지 않는 부분과 변하는 부분이 이미 클래스 레벨에서 컴파일 시점에 그 관계가 결정되어 있다.
(클라이언트(UserDaoTest)에서 deleteAll() 메소드를 쓰려면
UserDaoDeleteAll과 같이 구체적인 클래스와 관계를 직접 맺어야 한다는 의미인가?
아님 UserDao와 UserDaoDeleteAll가 관계되어 있다는 의미인가.)
관계에 대한 유연성이 떨어진다.

전략 패턴을 적용해보자.
객체를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만든다.
개방 폐쇄 원칙을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어나다.
컨텍스트(변하지 않는 부분)는 일정한 구조를 가지고 동작하다가
특정 확장 기능은 인터페이스(전략에 해당)를 통해 외부의 독립된 전략 클래스에 위임한다.
deleteAll()로 따지면 컨텍스트는 다음과 같다.
- DB 커넥션 가져오기
- PreparedStatement 만들어줄 외부 기능 호출하기
- 전달받은 PreparedStatement 실행하기
- 예외 발생시 이를 메소드 밖으로 던지기
- 어떤 경우든 PreparedStatement와 Connection 닫기
두 번째 작업에서 사용하는 PreparedStatement를 만들어주는 외부 기능이 바로
전략 패턴에서 말하는 전략이라고 볼 수 있다.

전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서 전략을 바꿔 쓸 수 있어야 하는데
컨텍스트 안에서 이미 구체적인 전략 클래스 DeleteAllStatement를 사용하도록 고정되어 있다.
뭔가 이상하다. 컨텍스트가 StatementStrategy 인터페이스뿐 아니라 특정 구현 클래스인
DeleteAllStatement도 직접 알고 있다는건 전략 패턴에도, OCP에도 잘 들어맞지 않는다.

전략 패턴에 따르면 컨텍스트가 어떤 전략을 사용하게 할 것인가는
클라이언트가 결정하는 게 일반적이다. 클라이언트가 구체적인 전략의 하나를 선택하고
객체로 만들어서 컨텍스트에 전달하는 것이다.
그렇다. 이건 DI다. DI란 결국 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조이다.
컨텍스트에 해당하는 부분을 별도의 메소드로 독립시켜보자.
클라이언트는 전략 클래스 객체를 컨텍스트 메소드로 전달해야 한다.

이번엔 add() 메소드에도 적용해보자.

20.8.6.

좀 더 개선할 부분을 찾아보자.
1. DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다.
2. DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적 정보가 있는 경우
이를 위해 객체를 전달받는 생성자와 이를 저장해둘 인스턴스 변수가 필요하다.

StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고
UserDao 클래스 안에 내부 클래스로 정의하자.
DeleteAllStatement나 AddStatement 모두 UserDao에서만 사용되고,
UserDao의 메소드 로직에 강하게 결합되어 있다.

익명 내부 클래스로 바꿔보자.

UserDao의 메소드가 클라이언트이고,
익명 내부 클래스가 개별적인 전략이고,
jdbcContextWithStatementStrategy() 메소드가 컨텍스트이다.
jdbcContextWithStatementStrategy()는 일반적인 작업 흐름을 담고 있어서
다른 DAO에서도 사용가능하므로 UserDao 클래스 밖으로 독립시켜서 모든 DAO가 사용할 수 있게 하자.

20.8.7.

UserDao와 StatementStrategy, JdbcContext를 이용해 만든 코드는
일종의 전략 패턴이 적용된 것이라고 볼 수 있다.
복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고
그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조다.
전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다.
이런 방식을 스프링에서는 템플릿/콜백 패턴이라고 부른다.
전략 패턴의 컨텍스트를 템플릿이라 부르고,
익명 내부 클래스로 만들어지는 객체를 콜백이라고 부른다.

템플릿/콜백 방식에서 한 가지 아쉬운 점이 있다.
DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에
상대적으로 코드를 작성하고 읽기가 불편하다는 점이다.
복잡한 익명 내부 클래스의 사용을 최소화할 수 있는 방법을 찾아보자.
deleteAll() 메소드에서 변하지 않는 부분(익명 내부 클래스를 정의하고 생성하는 부분)을
executeSql()라는 이름의 메소드로 추출하자.

한 단계 더 나아가자. executeSql()은 재사용 가능한 콜백을 담고 있는 메소드이므로
DAO가 공유할 수 있는 템플릿 클래스(JdbcContext) 안으로 옮겨도 된다.

정리
결합을 느슨하게 하기 위해 인터페이스 사용
-> 매번 인터페이스를 구현하는 클래스가 생성되므로 내부 클래스 이용
-> 익명 내부 클래스로 개선
-> 익명 내부 클래스를 정의하고 생성하는 로직이 반복되므로
반복되는 부분(템플릿)과 변하는 부분(콜백)을 분리

20.8.18. 템플릿/콜백 예제를 만들어보자.

파일의 모든 숫자를 더하는 기능을 만들었는데
모든 숫자의 곱을 계산하는 기능을 추가해야 한다는 요구가 발생했다고 가정해보자.
뿐만 아니라 앞으로 숫자 데이터를 여러 방식으로 처리하는 기능이 추가될 것이라는 소식이 들려왔다면?
자, 템플릿/콜백 패턴을 적용해보자.
템플릿/콜백을 적용할 때는 템플릿과 콜백의 경계를 정하고
템플릿이 콜백에게, 콜백이 템플릿에게 각각 전달하는 내용이 무엇인지 파악하는 게 가장 중요하다.

가장 쉽게 생각해볼 수 있는 구조는 템플릿이 파일을 열고 각 라인을 읽어올 수 있는
BufferedReader를 만들어서 콜백에게 전달해주고,
콜백이 각 라인을 읽어서 알아서 처리한 후에 최종 결과만 템플릿에게 돌려주는 것이다.

템플릿/콜백 패턴을 적용해서 try/catch/finally 블록이 없도록 깔끔하게 정리하였다.
calcSum()과 calcMultiply()에 나오는 콜백을 비교해보면 공통적인 패턴을 발견할 수 있다.
라인을 한 줄 한 줄 읽는 것까지 똑같고, 그 한 줄을 어떻게 처리하느냐만 다르다.
따라서 LineCallback 이라는 인터페이스를 새로 만들고,
라인을 읽는 것까지 템플릿에 넣고, 라인을 가지고 처리하는 부분만 콜백으로 두자.
(그래서 이름이 LineCallback이다.)
템플릿/콜백을 재설계해보자.

앞에서 만들었던 코드보다 깔끔하고 보기 좋다.
여타 로우레벨의 파일 처리 코드가 템플릿으로 분리되고
순수한 계산 로직만 남아 있기 때문에 코드의 관심이 무엇인지 명확하게 보인다.
Calculator 클래스와 메소드는 데이터를 가져와 계산한다는
핵심 기능에 충실한 코드만 갖고 있게 됐다.

20.9.5. 이제부턴 마크다운으로 작성해보자.

###제네릭스를 이용한 콜백 인터페이스
지금까지 사용한 LineCallBack과 lineReadTemplate()은 템플릿과 콜백이 만들어내는 결과가 Integer 타입으로 고정되어 있다.
파일을 라인 단위로 처리해서 만드는 결과의 타입을 다양하게 가져가고 싶다면, 제네릭스를 이용하면 된다.

20.9.6.

스프링이 제공하는 템플릿/콜백 기술을 살펴보자.
스프링이 제공하는 JDBC 코드용 기본 템플릿은 JdbcTemplate이다.
JdbcContext는 버리고 JdbcTemplate으로 바꿔보자.

20.9.11.

3장 끝.

##4장 예외

4장에서는 JdbcTemplate을 대표로 하는 스프링의 데이터 액세스 기능에 담겨 있는 예외처리와 관련된 접근 방법을 알아본다.
이를 통해 예외를 처리하는 best practice도 살펴본다.

20.10.8.

##5장 서비스 추상화

UserDao에 간단한 비즈니스 로직을 추가해보자.

- 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다.
- 사용자가 처음 가입하면 BASIC 레벨, 이후 활동에 따라 한 단계씩 업그레이드 가능하다.
- 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER가 된다.
- SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD가 된다.
- 사용자 레벨 변경 작업은 일정한 주기를 가지고 일괄적으로 한다.
변경 작업 전에는 조건을 충족하더라도 레벨 변경이 일어나지 않는다.

필드를 추가하자.

1. Level 이늄 추가
<br> 숫자 타입을 직접 사용하는 것보다는 enum을 사용하는 게
안전하고 편리하다.

2. User 필드 추가
<br> User에 Level 타입 필드와 로그인 횟수, 추천받은 횟수를
 나타내는 필드를 추가한다.
 
 20.10.9.
 
 사용자 수정 기능을 추가했다. 사용자 관리 비즈니스
 로직에 따르면 사용자 정보는 여러 번 수정될 수 있으니 말이다.
 
 만들어야 할 코드의 기능을 생각해볼 겸 테스트를 먼저 작성한다.
 
 사용자 레벨을 업그레이드 해주는 upgradeLevels 메소드를 추가했다.
 이는 비즈니스 로직이므로 UserService라는 클래스를 만들어
 그 안에 넣었다.
 
 코드 개선을 해보자.
 - 코드에 중복된 부분은 없는가
 - 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가
 - 코드가 자신이 있어야 할 자리에 있는가
 - 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고,
 그 변화에 쉽게 대응할 수 있게 작성되어 있는가
 
 ##### upgradeLevels() 개선

for 루프 속 if/elseif/else 블록들이 읽기 불편하다.
성격이 다른 여러 조직이 한데 섞여있는 상태이다.
if 조건 블록은 레벨 개수만큼 반복되는데 새로운 레벨이 추가될 경우
Level 이늄도 수정해야 하고, upgradeLevels()의
레벨 업그레이드 로직을 담은 코드에 if 조건식과
블록을 추가해줘야 한다. 즉, 지금의 코드는
변화에 취약하고 다루기 힘든 상태이다. 리팩토링을 해보자.

UserService는 User에게 레벨 업그레이드 작업을 해달라고
요청하고, User는 Level에게 다음 레벨이 무엇인지
알려달라고 요청하는 방식으로 리팩토링 되었다.
더 이해하기 쉽고 변화에 대응하기 편하다.
"BRONZE 레벨을 BASIZ과 SILVER 사이에 추가하고
그 다음 레벨로 업그레이드 하는 조건은 로그인 횟수 80번이다.
그리고 가장 최근의 레벨 변경 날짜를 저장해두고,
레벨 변경 시 콘솔에 로그를 남기도록 하라"는 수정
요청이 들어왔을 때, 각 요청사항은 어디를 손보면
되는지 쉽게 알 수 있다. 물론 변경 후에도
코드는 여전히 깔끔하고 이해하기 쉬울 것이다.

유저 레벨 업그레이드 정책을 유연하게 변경할 수 있도록
리팩토링해보자. 사용자 관리 로직을 담은 중요한
UserService 코드를 매번 수정하는건 번거롭고 위험하므로
업그레이드 정책을 UserService에서 분리해내고
업그레이드 정책을 담은 객체는 DI를 통해
UserService에서 사용하도록 해보자.