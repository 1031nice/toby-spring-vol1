20.7.14.
객체지향의 세계에서는 모든 것이 변한다.
여기서 변한다는 것은 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다.
소프트웨어 개발에서 끝이란 개념은 없다.
그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 '미래의 변화를 어떻게 대비할 것인가'이다.

객체지향 기술은 변화에 효과적으로 대체할 수 있다.
객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고,
이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다.

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까?
분리와 확장을 고려한 설계가 필요하다.

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
하지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다면? ...
변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은
한 가지 관심이 한 군데에 집중되게 하는 것이다.
즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

UserDao의 메소드를 살펴보면 다음의 관심사항을 발견할 수 있다.
1. DB와 연결을 위한 connection 가져오기
-어떤 DB를 쓸 것인가
-어떤 드라이버를 사용할 것인가
-어떤 로그인 정보를 사용할 것인가
-connection 생성 방법은 어떻게 할 것인가

2. DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행

3. 리소스(Statement, Connection) 반납


    1 단계. Connection 만들기 추출

가장 먼저 할 일은 connection을 가져오는 중복된 코드를 분리하는 것이다.
getConnection()이라는 이름의 독립적인 메소드를 만들었다.

이젠 클라이언트 쪽에서 연결을 알아서 구현하도록 수정해보자.
UserDao를 추상클래스로 만들고 getConnection()을 추상메소드로 만들었다.
다음으로 가상의 클라이언트 Dao를 만든 뒤,
클라이언트 Dao에서 UserDao를 상속받아 getConnection만 구현하도록 하였다.
이렇게 수퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를
추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을
디자인 패턴에서 템플릿 메소드 패턴이라고 한다.
템플릿 메소드 패턴은 스프링에서 애용되는 디자인 패턴이다.
서브클래스에서 구체적인 객체 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴이라고 부르기도 한다.

상속은 한계가 있다.
1. 이미 UserDao가 다른 목적을 위해 상속을 사용하고 있는 경우 상속을 이용할 수 없다(자바는 클래스 다중상속 불가능)
2. 상속을 통한 상하위 클래스 관계는 생각보다 밀접하다
   서브클래스는 수퍼클래스의 기능을 직접 사용할 수 있고, 따라서 수퍼클래스 내부의 변경이 있을 때
   모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.
3. 확장된 기능인 DB connection 생성 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다.


    2 단계. DAO 확장(interface 이용)

이번에는 관심사가 다르고 변화의 성격이 다른 코드를 더 화끈하게 분리해보도록 한다.
아예 상속관계도 아닌 완전히 독립적인 클래스로 만드는 것이다.
이제 더이상 클라이언트가 DB connection 기능 확장해서 사용할 수 없게 된다
UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되버리기 때문에
UserDao 코드의 수정 없이 DB connection 생성 기능을 변경할 방법이 없다.
이렇게 클래스를 분리한 경우에도 자유로운 확장이 가능하려면 두 가지가 해결되어야 한다.
1. SimpleConnectionMaker의 메소드 이름과
클라이언트에서 만든 DB connection 제공 클래스의 메소드 이름이 불일치 할 수 있다.
2. DB connection을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다.
UserDao에 SimpleConnectionMaker라는 클래스 타입의 인스턴스 변수까지 정의해놓고 있기 때문.
이런 문제의 근본 원인은 UserDao가 바뀔 수 있는 정보,
즉 DB connection을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다.
어떤 클래스가 쓰일지, 그 클래스에서 connection을 가져오는 메소드의 이름이 뭔지까지 일일이 알고 있어야 한다.
따라서 UserDao는 DB connection을 가져오는 코드에 종속되어 버린다.
클라이언트가 DB connection을 가져오는 방법을 자유롭게 확장하기가 힘들어졌다.

