20.7.14.
객체지향의 세계에서는 모든 것이 변한다.
여기서 변한다는 것은 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다.
소프트웨어 개발에서 끝이란 개념은 없다.
그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 '미래의 변화를 어떻게 대비할 것인가'이다.

객체지향 기술은 변화에 효과적으로 대체할 수 있다.
객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고,
이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다.

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까?
분리와 확장을 고려한 설계가 필요하다.

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
하지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다면? ...
변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은
한 가지 관심이 한 군데에 집중되게 하는 것이다.
즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

UserDao의 메소드를 살펴보면 다음의 관심사항을 발견할 수 있다.
1. DB와 연결을 위한 connection 가져오기
-어떤 DB를 쓸 것인가
-어떤 드라이버를 사용할 것인가
-어떤 로그인 정보를 사용할 것인가
-connection 생성 방법은 어떻게 할 것인가

2. DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행

3. 리소스(Statement, Connection) 반납


    1 단계. Connection 만들기 추출

가장 먼저 할 일은 connection을 가져오는 중복된 코드를 분리하는 것이다.
getConnection()이라는 이름의 독립적인 메소드를 만들었다.

이젠 클라이언트 쪽에서 연결을 알아서 구현하도록 수정해보자.
UserDao를 추상클래스로 만들고 getConnection()을 추상메소드로 만들었다.
다음으로 가상의 클라이언트 Dao를 만든 뒤,
클라이언트 Dao에서 UserDao를 상속받아 getConnection만 구현하도록 하였다.
이렇게 수퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를
추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을
디자인 패턴에서 템플릿 메소드 패턴이라고 한다.
템플릿 메소드 패턴은 스프링에서 애용되는 디자인 패턴이다.
서브클래스에서 구체적인 객체 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴이라고 부르기도 한다.

상속은 한계가 있다.
1. 이미 UserDao가 다른 목적을 위해 상속을 사용하고 있는 경우 상속을 이용할 수 없다(자바는 클래스 다중상속 불가능)
2. 상속을 통한 상하위 클래스 관계는 생각보다 밀접하다
   서브클래스는 수퍼클래스의 기능을 직접 사용할 수 있고, 따라서 수퍼클래스 내부의 변경이 있을 때
   모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.
3. 확장된 기능인 DB connection 생성 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다.


    2 단계. DAO 확장(interface 이용)

이번에는 관심사가 다르고 변화의 성격이 다른 코드를 더 화끈하게 분리해보도록 한다.
아예 상속관계도 아닌 완전히 독립적인 클래스로 만드는 것이다.
이제 더이상 클라이언트가 DB connection 기능 확장해서 사용할 수 없게 된다
UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되버리기 때문에
UserDao 코드의 수정 없이 DB connection 생성 기능을 변경할 방법이 없다.
이렇게 클래스를 분리한 경우에도 자유로운 확장이 가능하려면 두 가지가 해결되어야 한다.
1. SimpleConnectionMaker의 메소드 이름과
클라이언트에서 만든 DB connection 제공 클래스의 메소드 이름이 불일치 할 수 있다.
2. DB connection을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다.
UserDao에 SimpleConnectionMaker라는 클래스 타입의 인스턴스 변수까지 정의해놓고 있기 때문.
이런 문제의 근본 원인은 UserDao가 바뀔 수 있는 정보,
즉 DB connection을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다.
어떤 클래스가 쓰일지, 그 클래스에서 connection을 가져오는 메소드의 이름이 뭔지까지 일일이 알고 있어야 한다.
따라서 UserDao는 DB connection을 가져오는 코드에 종속되어 버린다.
클라이언트가 DB connection을 가져오는 방법을 자유롭게 확장하기가 힘들어졌다.

20.7.16.
클래스를 분리하면서도 이런 문제를 해결할 수 없을까?
두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들면 된다.
추상화란 어떤 것들의 공통적 성격을 뽑아내어 이를 따로 분리해내는 작업인데,
자바가 추상화를 위해 제공하는 가장 유용한 도구가 바로 인터페이스다.
인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다.
결국 객체를 만들려면 구체적인 클래스 하나를 선택해야겠지만
인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들 때
사용할 클래스가 무엇인지 몰라도 된다.
인터페이스를 통해 접근하게 되면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.
ConnectionMaker라는 이름의 인터페이스를 만들어
클라이언트 쪽에서 connection 생성 코드를 알아서 만들도록 수정하자.
(의존관계가 UserDao와 인터페이스 사이에 형성되기 때문에
인터페이스 구현 클래스와의 관계가 느슨해지면서 변화에 영향을 덜 받는 상태가 되었다.)
수정을 하고 보니 UserDao의 인스턴스 변수 ConnectionMaker 객체를 생성할 때
클라이언트의 클래스 이름이 나온다는 문제가 생겼다.
ex) connectionMaker = new KakaoConnectionMaker();
이렇게 되면 클라이언트에게 UserDao 소스코드를 제공해야만 한다.
수정할 때 UserDao의 소스코드를 직접 수정해주어야 하기 때문이다.

UserDao 안에 분리되지 않은, 또 다른 관심사항이 있다.
바로 어떤 ConnectionMaker 클래스를 사용할 것인가 하는 문제이다.
매우 짧고 간단하지만 그 자체로 충분히 독립적인 관심사이다.
이 관심사를 담은 코드를 UserDao에서 분리하지 않으면
UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.
UserDao 객체와 ConnectionMaker 구현 클래스 객체의 관계를 결정하는 기능은
클라이언트 오브젝트에 두도록 하자. UserDao의 모든 코드가 ConnectionMaker 인터페이스 외에
다른 어떤 클래스와도 관계를 갖지 않도록 말이다.
외부(클라이언트 객체)에서 만든 객체를 전달받으려면
메소드 파라미터나 생성자 파라미터를 이용하면 된다.

주의)
클래스 사이에 만들어진 관계와 객체 사이에 만들어진 관계는 다르다.
UserDao에서 ConnectionMaker 구현 클래스로 KakaoConnectionMaker 클래스를 사용하면,
이는 클래스 사이에 관계가 형성된 것이다.
하지만 다형성이라는 특징을 이용해 인터페이스로 연결하여
런타임에 해당 인터페이스를 구현한 클래스 객체를 받게한다면,
이는 특정 클래스와 관계를 맺은 것이 아니라
런타임시에 객체 사이에 관계가 형성된 것이다.

클라이언트는 자기가 UserDao를 사용해야 할 입장이기 때문에
UserDao의 세부 전략이라고도 볼 수 있는 ConnectionMaker의 구현 클래스를 선택하고,
선택한 클래스의 객체를 생성해서 UserDao와 연결해줄 수 있다.
기존의 UserDao에서는 생성자에게 이 책임이 있었다.
자신이 사용할 객체를 직접 만들어서, 자신과 관계를 만들어버리는 것이 기존 UserDao 생성자가 한 일이다.
하지만 이는 UserDao의 관심도 아니고 책임도 아니다. 다른 관심사가 함께 있으니 확장성을 떨어뜨렸던 것이다.
자, 이제 이 다른 관심을 분리해서 클라이언트에게 떠넘겨보자.
클라이언트에서 ConnectionMaker 구현 클래스를 정하고 객체를 생성하여 UserDao의 생성자에 전달하게 수정하였다.
이제 UserDao의 생성자는 ConnectionMaker 인터페이스를 구현했다면
어떤 클래스로 만든 오브젝트라도 상관도 없고 관심도 없다.

20.7.17.
얼렁뚱땅 넘긴 게 하나 있다. 클라이언트인 UserDaoTest이다.
UserDaoTest는 UserDao 기능이 잘 동작하는지 테스트하려고 만든 것이다.
근데 지금은 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 책임까지 떠맡았으니 뭔가 문제가 있다.
성격이 다른 책임이나 관심사는 지금껏 분리해왔기 때문이다. 이것도 분리하자.
분리시킬 기능을 담당할 클래스 DaoFactory를 만들자.
이로써 애플리케이션 컴포넌트 역할을 하는 객체(클라이언트, UserDao, ConnectionMaker)와
애플리케이션 구조를 결정하는 객체(DaoFactory)가 분리되었다.

20.7.19.
DaoFactory를 좀 더 살펴보자.
DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능을 넣고 싶다.
AccountDao, MessageDao 등..
근데 userDao() 메소드를 복사해서 accountDao(), messageDao() 메소드로 만들면
ConnectionMaker 구현 클래스의 객체를 생성하는 코드가 메소드마다 반복된다.
(어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 기능이 중복돼서 나타난다.)
이럴 경우 DAO가 더 많아지면 ConnectionMaker의 구현 클래스를 바꿀 때마다
모든 메소드를 일일이 수정해야 한다.
ConnectionMaker 구현 클래스의 객체를 생성하는 코드를
connectionMaker()라는 이름의 메소드로 뽑아내자.

이제 제어의 역전에 대해 알아보자.
제어의 역전은 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.
객체가 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하는 것으로
자신이 사용할 객체를 스스로 선택하거나 생성하지 않고,
어떻게 만들어지고 어디서 사용되지 알 수 없다.
UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다.
자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해
DaoFactory를 도입했던 과정이 바로 IoC를 적용하는 작업이었다고 볼 수 있다.

제어의 역전에서는 프레임워크 또는 컨테이너와 같이
애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.
DaoFactory는 객체 수준의 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크라고 불릴 수 있다.

스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 객체를 빈 팩토리라 부른다.
보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트를 사용한다.

DaoFactory는 자체가 설정정보까지 담고 있는 IoC 엔진이었으나
이제 자바 코드로 만든 애플리케이션 컨텍스트가 사용할 설정정보로 만든 뒤,
애플리케이션 컨텍스트를 만들어보자.

20.7.20.
XML을 이용하여 애플리케이션 컨텍스트를 만들어보자.

자바에서는 DB 커넥션을 가져오는 객체의 기능을 추상화해서
비슷한 용도로 사용할 수 있게 만들어진 DataSource라는 인터페이스가 이미 존재한다.
따라서 실전에서 ConnectionMaker와 같은 인터페이스를 만들어서 사용할 일은 없을 것이다.
DataSource를 구현하는 일도 거의 없다. 이미 DB 연결과 pooling 기능을 갖춘
많은 DataSource 구현 클래스가 존재하기 때문이다.
DataSource 인터페이스와 다양한 DataSource 구현 클래스를 사용할 수 있도록 UserDao를 리팩토링해보자.

20.7.24.
UserDaoTest에 아쉬운 점이 있다.
하나는 수동으로 확인해야 한다는 점이다.
add()에서 User 정보를 DB에 등록하고, 이를 다시 get()으로 가져왔을 때
값이 일치하는지를 테스트 코드가 확인해주지 않는다.
단지 콘솔에 값을 출력할 뿐이고, 사람이 눈으로 확인해야 한다.
또 하나는 실행하기가 번거롭다는 점이다.
DAO가 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면,
전체 기능을 테스트해보기 위해 main() 메소드를 수백 번 실행해야 한다.
main() 메소드를 이용하는 방법보다 좀 더 편리하고 체계적으로 테스트를 실행하고
그 결과를 확인하는 방법이 필요하다.

먼저 첫 번째 문제점을 개선해보자.
테스트 코드에서 결과를 직접 확인하고,
기대한 결과와 달라서 실패했을 경우에는
"테스트 실패"라는 메시지를 출력하도록 만들어보자.
그리고 모든 확인 작업을 통과하면 그때 "테스트 성공"을 출력하자.

20.7.26.
좀 더 편리하게 테스트를 수행하고 편리하게 결과를 확인하려면
단순한 main() 메소드로는 한계가 있다
일정한 패턴을 가진 테스트를 만들 수 있고,
많은 테스트를 간단히 실행시킬 수 있으며,
테스트 결과를 종합해서 볼 수 있고,
테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘
테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.
JUnit 프레임워크를 사용하자.

deleteAll()과 getCount() 메소드를 추가해보자.
두 메소드에 대한 테스트는 기존의 addAndGet() 테스트에 추가한다.

20.7.27.
getCount()에 대한 더 꼼꼼한 테스트를 만들어보자.
테스트를 안 만드는 것도 위험하지만,
성의 없이 테스트를 만드는 바람에
문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다.
테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 게 좋으니까
getCount()를 위한 새로운 테스트 메소드를 작성하도록 한다.

addAndGet() 테스트를 보완해보자.

UserDao의 get()에 존재하지 않는 user id가 전달된 경우를 처리해보자.
스프링의 EmptyResultDataAccessException 예외를 이용한다.

20.7.28.
지금까지 세 개의 테스트 메소드를 만들었다. 이쯤 해서 테스트 코드를 리팩토링해보자.

UserDaoTest 코드를 잘 살펴보면 기계적으로 반복되는 부분이 있다.
스프링의 애플리케이션 컨텍스트를 만드는 부분과
컨텍스트에서 UserDao를 가져오는 부분이다.
메소드 추출 리팩토링 방법 말고 JUnit이 제공하는 기능을 활용해보자.

JUnit 프레임워크는 테스트 메소드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다.
그중에서 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣게 해주고,
이를 매번 테스트 메소드를 실행하기 전에 먼저 실행시켜주는 기능이다. @Before